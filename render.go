// Copyright 2014 Brett Slatkin
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
    "fmt"
    "io"
    "path/filepath"
    "strings"
    "text/template"
)

var (
    cTemplate = template.Must(template.New("render").Parse(`#define Py_LIMITED_API
#include <Python.h>

const char* getByteArrayPointer(PyObject * args) {
    const char* bytes;
    int count;

    if (!PyArg_ParseTuple(args, "s#", &bytes, &count))
    {
        return NULL;
    }

    return bytes;
}

int getByteCount(PyObject * args) {
    const char* bytes;
    int count;

    if (!PyArg_ParseTuple(args, "s#", &bytes, &count))
    {
        return 0;
    }

    return count;
}

{{range .Functions}}
PyObject * {{.Name}}(PyObject *, PyObject *);

char DOC_{{.Name}}[] = "{{.Documentation}}";
{{end}}

static PyMethodDef Methods[] = {
{{range .Functions}}
    {"{{.Name}}", {{.Name}}, METH_VARARGS, DOC_{{.Name}}},
{{end}}
    {NULL, NULL, 0, NULL}
};

static struct PyModuleDef module = {
   PyModuleDef_HEAD_INIT, "{{.PackageName}}", NULL, -1, Methods
};

PyMODINIT_FUNC
PyInit_{{.PackageName}}(void)
{
    return PyModule_Create(&module);
}`))
    goTemplate = template.Must(template.New("render").Parse(`// Code generated by goprotopy - DO NOT EDIT.
package main

// #cgo pkg-config: python3
// #cgo CFLAGS: -std=gnu99
// #define Py_LIMITED_API
// #include <Python.h>
// char* getByteArrayPointer(PyObject *);
// Py_ssize_t getByteCount(PyObject *);
import "C"
import "unsafe"
import {{.PackageName}} "{{.FullPackageName}}"

//go:generate go build -buildmode=c-shared -o {{.PackageName}}.so

func main() {}

func getGoBytes(pyObject *C.PyObject) (slice []byte) {
    length := C.getByteCount(pyObject)

    var CMessageIn *C.char = C.getByteArrayPointer(pyObject)
    slice = (*[1 << 30]byte)(unsafe.Pointer(CMessageIn))[:length:length]

    return
}

func getPyBytes(bytes []byte) (res *C.PyObject) {
    asString := string(bytes)
    p := unsafe.Pointer(C.CString(asString))
    defer C.free(p)
    res = C.PyBytes_FromStringAndSize((*C.char)(p), C.Py_ssize_t(len(asString)))

    return
}

type wrappedCall func(*C.PyObject) *C.PyObject
type apiCall func([]byte) ([]byte, error)

func wrap(goFunction apiCall) (pyFunction wrappedCall) {
    pyFunction = func(pyArgs *C.PyObject) (pyResult *C.PyObject) {
        messageOut, err := goFunction(getGoBytes(pyArgs))
        if err != nil {
            // Raise a generic exception in Python
            C.PyErr_SetString(C.PyExc_RuntimeError, C.CString(err.Error()));
            return
        }

        pyResult = getPyBytes(messageOut)
        return
    }
    return
}

{{range .Functions}}
//export {{.Name}}
func {{.Name}}(self, args *C.PyObject) *C.PyObject {
  return wrap({{$.PackageName}}.{{.Name}})(args)
}
{{end}}
`))
)

type GeneratedFunction struct {
    Name string
    Documentation string
}

func getRenderedPath(inputPath, outputFolder, extension string) (string, error) {
    if !strings.HasSuffix(inputPath, ".go") {
        return "", fmt.Errorf("Input path %s doesn't have .go extension", inputPath)
    }
    trimmed := strings.TrimSuffix(inputPath, ".go")
    _, file := filepath.Split(trimmed)
    return filepath.Join(outputFolder, fmt.Sprintf("%s.%s", file, extension)), nil
}

type generateTemplateData struct {
    FullPackageName string
    PackageName string
    Functions   []GeneratedFunction
}

func render(w io.Writer, fullPackageName string, packageName string, functions []GeneratedFunction) (err error) {
    return goTemplate.Execute(w, generateTemplateData{fullPackageName, packageName, functions})
}

func renderC(w io.Writer, fullPackageName string, packageName string, functions []GeneratedFunction) (err error) {
    return cTemplate.Execute(w, generateTemplateData{fullPackageName, packageName, functions})
}

